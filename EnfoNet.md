# EnfoNet

```
基于ZeroMQ的高性能消息队列
      ==============EnfoMQ:高性能消息队列框架==============
          生产者1             生产者2             生产者3
       ------------        ------------        ------------
      | MQProducer |      | MQProducer |      | MQProducer |
      |------------|      |------------|      |------------|
      |    PUB     |      |    PUB     |      |    PUB     |
       ------------        ------------        ------------
         connect              connect            connect
            |                    |                  |
            -----------------------------------------
                                 |
                                bind
                                 |
                           ------------
                          |    XSUB    |
                          |------------|
                          |   MQProxy  |  ---消息队列代理
                          |------------|
                          |    XPUB    |
                           ------------
                                 |
                                bind
                                 |
            -----------------------------------------
            |                    |                  |
         connect              connect            connect
       ------------        ------------        ------------
      |    SUB     |      |     SUB    |      |     SUB    |
      |------------|      |------------|      |------------|
      | MQConsumer |      | MQConsumer |      | MQConsumer |
       ------------        ------------        ------------
          消费者1             消费者2              消费者3

```



```
基于ZeroMQ的高性能Request/Response引擎，具备服务负载均衡(Service Load Balance)能力
      =============EnfoSLB:高性能服务负载均衡框架=============
          客户端1              客户端2             客户端3
       ------------        ------------        ------------
      | SLBClient  |      | SLBClient  |      | SLBClient  |
      |------------|      |------------|      |------------|
      |    REQ     |      |    REQ     |      |    REQ     |
       ------------        ------------        ------------
         connect              connect            connect
            |                    |                  |
            -----------------------------------------
                                 |
                                bind
                                 |
                           ------------
                          |   ROUTER   |
                          |------------|
                          |  SLBProxy  |  ---服务代理
                          |------------|
                          |   DEALER   |
                           ------------
                                 |
                                bind
                                 |
            -----------------------------------------
            |                    |                  |
         connect              connect            connect
       ------------        ------------        ------------
      |    REP     |      |     REP    |      |     REP    |
      |------------|      |------------|      |------------|
      | SLBServer  |      | SLBServer  |      | SLBServer  |
       ------------        ------------        ------------
        服务节点1             服务节点2           服务节点3
```



## 1.技术组成

### 1.1 消息队列：ZeroMQ

在微服务架构中，排除纯粹的“事件驱动架构”，使用消息队列的场景一般是为了进行微服务之间的解耦。服务之间不需要了解是由哪个服务实例来消费或者发布消息。只要处理好自己领域范围的逻辑，然后通过消息通道来发布，或者订阅自己关注的消息就可以。

消息队列的模型中，主要的三个组成:

- **Producer**：生产消息，将消息写入 channel。

- **Message Broker**：消息代理，将写入 channel 的消息按队列的结构进行管理。负责存储/转发消息。Broker 一般是需要单独搭建、配置的集群，而且必须是高可用的。

- **Consumer**：消息的消费者。目前大多数的消息队列都是保证消息至少被消费一次。所以根据使用的消息队列设施不同，消费者要做好幂等。

### 1.2 服务器负载均衡(Server Load Balancer):（Nginx？）

### 1.3 服务注册中心(Server Registe Center):(zookeeper?)

服务之间需要创建一种服务发现机制，用于帮助服务之间互相感知彼此的存在。服务启动时会将自身的服务信息注册到注册中心，并订阅自己需要消费的服务。

服务注册中心是服务发现的核心。它保存了各个可用服务实例的网络地址（IPAddress和Port）。

### 1.4 微服务调度/通信框架：RPC，Google ProtoBuf

RPC主要是为了解决的两个问题：

- 分布式系统中，服务之间的调用问题
- 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑

RPC使用中的序列化与反序列化：

- 把变量从内存中变成可存储或传输的过程称之为序列化，序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
- 把变量内容从序列化的对象重新读到内存里称之为反序列化

**平台使用Google ProtoBuf**

Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。

ProtoBuf 效率高的原因

- Protobuf 序列化
-  Protobuf 封解包

### 1.5 微服务框架（SMD）：

## 2. 微服务架构要考虑的问题

### 2.1 API Gateway

### 2.2 服务间调用

### 2.3 服务容错

### 2.4 服务部署

### 2.5 数据调用

**幂等性**

## 3. 架构的要素

架构五要素：

**高性能**：消息队列、RxJava异步并发、分布式缓存、本地缓存、Http的Etag缓存、使用Elasticsearch优化查询、CDN等

**可用性：**容器服务集群、RxJava的熔断处理、服务降级、消息的幂等处理、超时机制、重试机制、分布式最终一致性等

**伸缩性：**服务器集群的伸缩、容器编排Kubernetes、数据库分库分表、Nosql的线性伸缩、搜索集群的可伸缩等

**扩展性：**基于Docker的微服务本身就是为了扩展性而生

**安全性：**JPA/Hibernate,SpringSecurity、高防IP、日志监控、Https、Nginx反向代理、HTTP/2.0等